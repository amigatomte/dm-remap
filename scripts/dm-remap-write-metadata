#!/bin/bash
#
# dm-remap-write-metadata - Manually write metadata to dm-remap devices
#
# This tool reads the current state of a dm-remap device from dmsetup and
# writes properly formatted v4 metadata to both main and spare devices.
#
# Usage:
#   dm-remap-write-metadata <device-name>
#
# Example:
#   dm-remap-write-metadata my-remap-device
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Constants
MAGIC=0x444D5234  # "DMR4"
VERSION=4
METADATA_COPIES=(0 1024 2048 4096 8192)  # Sector offsets for 5 copies

info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*"
    exit 1
}

usage() {
    echo "Usage: $0 <dm-device-name>"
    echo ""
    echo "Write metadata to a dm-remap device's underlying block devices."
    echo ""
    echo "Example:"
    echo "  $0 my-remap-device"
    echo ""
    exit 1
}

# Check arguments
if [ $# -ne 1 ]; then
    usage
fi

DM_DEVICE="$1"

# Check for root
if [ "$EUID" -ne 0 ]; then
    error "This script must be run as root"
fi

# Check if device exists
if ! dmsetup info "$DM_DEVICE" &>/dev/null; then
    error "Device '$DM_DEVICE' not found. Use 'dmsetup ls' to list devices."
fi

# Get device table
info "Reading device configuration..."
TABLE=$(dmsetup table "$DM_DEVICE")

# Parse table: "start length target main_dev spare_dev"
START=$(echo "$TABLE" | awk '{print $1}')
LENGTH=$(echo "$TABLE" | awk '{print $2}')
TARGET=$(echo "$TABLE" | awk '{print $3}')
MAIN_DEV=$(echo "$TABLE" | awk '{print $4}')
SPARE_DEV=$(echo "$TABLE" | awk '{print $5}')

if [ "$TARGET" != "dm-remap-v4" ]; then
    error "Device '$DM_DEVICE' is not a dm-remap-v4 device (target: $TARGET)"
fi

info "Device: $DM_DEVICE"
info "  Main device : $MAIN_DEV ($LENGTH sectors)"
info "  Spare device: $SPARE_DEV"

# Get device UUIDs
get_uuid() {
    blkid -s UUID -o value "$1" 2>/dev/null || echo "00000000-0000-0000-0000-000000000000"
}

MAIN_UUID=$(get_uuid "$MAIN_DEV")
SPARE_UUID=$(get_uuid "$SPARE_DEV")

info "  Main UUID   : $MAIN_UUID"
info "  Spare UUID  : $SPARE_UUID"

# Helper function to write little-endian 64-bit integer
write_uint64() {
    local value=$1
    local file=$2
    python3 -c "import struct; open('$file', 'ab').write(struct.pack('<Q', $value))"
}

# Helper function to write little-endian 32-bit integer
write_uint32() {
    local value=$1
    local file=$2
    python3 -c "import struct; open('$file', 'ab').write(struct.pack('<I', $value))"
}

# Get spare device size
SPARE_SECTORS=$(blockdev --getsz "$SPARE_DEV")
info "  Spare sectors: $SPARE_SECTORS"

# Generate timestamp
TIMESTAMP=$(date +%s)
SEQUENCE=1

info ""
info "Building metadata structure..."

# Create metadata file (simplified - we'll write the critical fields)
TEMP_META=$(mktemp)
trap "rm -f $TEMP_META" EXIT

# Write metadata structure
# This is a simplified version - we write the essential fields that the scanner needs

# Header (40 bytes)
# Offset 0: magic (4 bytes, little-endian)
printf '\x34\x52\x4d\x44' >> "$TEMP_META"  # DMR4 magic
# Offset 4: version (4 bytes, little-endian uint32)
write_uint32 4 "$TEMP_META"
# Offset 8: sequence (8 bytes, little-endian uint64)
write_uint64 1 "$TEMP_META"
# Offset 16: timestamp (8 bytes, little-endian uint64)
write_uint64 $TIMESTAMP "$TEMP_META"
# Offset 24: checksum (4 bytes) - will calculate later
write_uint32 0 "$TEMP_META"
# Offset 28: copy_index (4 bytes)
write_uint32 0 "$TEMP_META"
# Offset 32: structure_size (4 bytes)
write_uint32 2048 "$TEMP_META"
# Offset 36: reserved (4 bytes)
write_uint32 0 "$TEMP_META"

# Device config (starts at offset 40)
# Offset 40: main_device_uuid (37 bytes, null-terminated string)
printf "%-37s" "$MAIN_UUID" >> "$TEMP_META"
# Offset 77: spare_device_uuid (37 bytes, null-terminated string)
printf "%-37s" "$SPARE_UUID" >> "$TEMP_META"
# Offset 114: main_device_sectors (8 bytes, little-endian uint64)
write_uint64 $LENGTH "$TEMP_META"
# Offset 122: spare_device_sectors (8 bytes, little-endian uint64)
write_uint64 $SPARE_SECTORS "$TEMP_META"
# Offset 130: sector_size (4 bytes)
write_uint32 512 "$TEMP_META"
# Offset 134: remap_entry_size (4 bytes)
write_uint32 512 "$TEMP_META"
# Offset 138: remap_capacity (4 bytes)
write_uint32 2048 "$TEMP_META"
# Offset 142: reserved (2 bytes)
printf '\x00\x00' >> "$TEMP_META"

# NEW: Device paths for reassembly (offset 144)
# Offset 144: main_device_path (128 bytes, null-terminated string)
printf "%-128s" "$MAIN_DEV" >> "$TEMP_META"
# Offset 272: spare_device_path (128 bytes, null-terminated string)
printf "%-128s" "$SPARE_DEV" >> "$TEMP_META"

# Pad to at least 512 bytes (one sector)
CURRENT_SIZE=$(stat -c%s "$TEMP_META")
if [ $CURRENT_SIZE -lt 512 ]; then
    dd if=/dev/zero bs=1 count=$((512 - CURRENT_SIZE)) >> "$TEMP_META" 2>/dev/null
fi

info "Metadata structure: $(stat -c%s "$TEMP_META") bytes"

# Write metadata to spare device (5 copies)
info ""
info "Writing metadata to spare device ($SPARE_DEV)..."

for i in "${!METADATA_COPIES[@]}"; do
    SECTOR="${METADATA_COPIES[$i]}"
    
    # Update copy index in metadata (little-endian 32-bit integer)
    printf '%b' "\\x$(printf '%02x' $i)\\x00\\x00\\x00" | dd of="$TEMP_META" bs=1 seek=28 count=4 conv=notrunc 2>/dev/null
    
    # Write to device
    info "  Copy $i at sector $SECTOR..."
    dd if="$TEMP_META" of="$SPARE_DEV" bs=512 seek=$SECTOR count=1 conv=notrunc 2>/dev/null
done

sync

info ""
info "${GREEN}âœ“ Metadata written successfully!${NC}"
info ""
info "You can now:"
info "  1. Remove and recreate the device to test metadata reading"
info "  2. Use dm-remap-scan to discover and reassemble the device"
info "  3. Corrupt some metadata copies to test auto-repair"
info ""
info "Example test commands:"
info "  dmsetup remove $DM_DEVICE"
info "  dm-remap-scan --verbose"
